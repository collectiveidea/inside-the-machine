<div id="cha-the_mechanics_of_program_execution" data-tralics-id="cid8" class="chapter" data-number="2" data-chapter="the_mechanics_of_program_execution"><h1><a href="the_mechanics_of_program_execution_fragment.html#cha-the_mechanics_of_program_execution" class="heading hyperref"><span class="number">Chapter 2 </span>The Mechanics of Program Execution</a></h1>
<p>Now that we understand the basics of computer organization, it’s time to take a
closer look at the nuts and bolts of how stored programs are actually executed by the computer.</p>
<p>To that end, this chapter will cover core programming concepts like machine language, the programming model, the instruction set architecture, branch instructions, and the fetch-execute loop.</p>
</div><div id="cid9" data-tralics-id="cid9" class="section" data-number="2.1"><h2><a href="the_mechanics_of_program_execution_fragment.html#cid9" class="heading hyperref"><span class="number">2.1 </span>Opcodes and Machine Language</a></h2>
<p>If you’ve been following the discussion so far, it shouldn’t surprise you to learn that both memory addresses and instructions are ordinary numbers that can be stored in memory.<span class="intersentencespace"></span> All of the instructions in a program like Program 1-1 are represented inside the computer as strings of numbers.<span class="intersentencespace"></span> Indeed, a program is one long string of numbers stored in a series of memory locations.<span class="intersentencespace"></span> ￼
How is a program like Program 1-1 rendered in numerical notation so that it can be stored in memory and executed by the computer?<span class="intersentencespace"></span> The answer is simpler than you might think.</p>
<p>As you may already know, a computer actually only understands 1s and 0s (or “high” and “low” electric voltages), not English words like <em>add</em>, <em>load</em>, and <em>store</em>, or letters and base-10 numbers like A, B, 12, and 13.<span class="intersentencespace"></span> In order for the computer to run a program, therefore, all of its instructions must be rendered in <em>binary notation</em>.<span class="intersentencespace"></span> Think of translating English words into Morse code’s dots and dashes and you’ll have some idea of what I’m talking about.</p>
<div id="uid46" data-tralics-id="uid46" class="subsection" data-number="2.1.1"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid46" class="heading hyperref"><span class="number">2.1.1 </span>Machine Language on the DLW-1</a></h3>
<p>The translation of programs of any complexity into this binary-based <em>machine language</em> is a massive undertaking that’s meant to be done by a computer, but I’ll show you the basics of how it works so you can understand what’s going on.<span class="intersentencespace"></span> The following example is simplified, but useful nonetheless.</p>
<p>The English words in a program, like <em>add</em>, <em>load</em>, and <em>store</em>, are <em>mnemonics</em> (meaning they’re easy for people to remember), and they’re all mapped to strings of binary numbers, called <em>opcodes</em>, that the computer can understand.<span class="intersentencespace"></span> Each opcode designates a different operation that the processor can perform.<span class="intersentencespace"></span> Table 2-1 maps each of the mnemonics used in Chapter 1 to a 3-bit opcode for the hypothetical DLW-1 microprocessor.<span class="intersentencespace"></span> We can also map the four register names to 2-bit binary codes, as shown in Table 2-2.</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Mnemonic</td>
<td class="align_left right_border">Opcode</td>
</tr><tr><td class="left_border align_left right_border"><code>add</code></td>
<td class="align_left right_border"><code>000</code></td>
</tr><tr><td class="left_border align_left right_border"><code>sub</code></td>
<td class="align_left right_border"><code>001</code></td>
</tr><tr><td class="left_border align_left right_border"><code>load</code></td>
<td class="align_left right_border"><code>010</code></td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>store</code></td>
<td class="align_left right_border"><code>011</code></td>
</tr></table>
<p>Table 2-1: Mapping of Mnemonics to Opcodes for the DLW-1</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Register</td>
<td class="align_left right_border">Binary Code</td>
</tr><tr><td class="left_border align_left right_border"><code>A</code></td>
<td class="align_left right_border"><code>00</code></td>
</tr><tr><td class="left_border align_left right_border"><code>B</code></td>
<td class="align_left right_border"><code>01</code></td>
</tr><tr><td class="left_border align_left right_border"><code>C</code></td>
<td class="align_left right_border"><code>10</code></td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>D</code></td>
<td class="align_left right_border"><code>11</code></td>
</tr></table>
<p>Table 2-2: Mapping of Registers to Binary Codes for the DLW-1</p>
<p>The binary values representing both the opcodes and the register codes are arranged in one of a number of 16-bit (or 2-byte) formats to get a complete <em>machine language instruction</em>, which is a binary number that can be stored in RAM and used by the processor.</p>
<div class="aside" id="aside-note_2-1" data-tralics-id="uid47" data-number="2.1"><div class="heading"><span class="number">Box 2.1.</span> 
</div>
<p class="noindent">Because programmer-written instructions must be translated into binary codes before a computer can read them, it is common to see programs in any format—binary, assembly, or a high-level language like BASIC or C, referred to generically as “code” or “codes.” So programmers sometimes speak of “assembler code,” “binary code,” or “C code,” when referring to programs written in assembly, binary, or C language.<span class="intersentencespace"></span> Programmers also will often describe the act of programming as “writing code” or “coding.” I have adopted this terminology in this book, and will henceforth use the term “code” regularly to refer generically to instruction sequences and programs.</p>

</div></div>
<div id="uid48" data-tralics-id="uid48" class="subsection" data-number="2.1.2"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid48" class="heading hyperref"><span class="number">2.1.2 </span>Binary Encoding of Arithmetic Instructions</a></h3>
<p>Arithmetic instructions have the simplest machine language instruction formats, so we’ll start with them.<span class="intersentencespace"></span> Figure 2-1 shows the format for the machine language encoding of a register-type arithmetic instruction.</p>
<div class="center figure" id="fig-2-1" data-tralics-id="uid49" data-number="2.1">
<div class="graphics image"><img src="images/figure_2-1.png" alt="images/figure_2-1" /></div><div class="caption"><span class="header">Figure 2.1: </span><span class="description">Machine language format for a register-type instruction
</span></div></div>
<p>In a register-type arithmetic instruction (that is, an arithmetic instruc- tion that uses only registers and no immediate values), the first bit of the instruction is the <em>mode bit</em>.<span class="intersentencespace"></span> If the mode bit is set to 0, then the instruction is a register-type instruction; if it’s set to 1, then the instruction is of the immediate type.</p>
<p>Bits 1–3 of the instruction specify the opcode, which tells the computer what type of operation the instruction represents.<span class="intersentencespace"></span> Bits 4–5 specify the instruc- tion’s first source register, 6–7 specify the second source register, and 8–9 specify the destination register.<span class="intersentencespace"></span> The last six bits are not needed by register-to- register arithmetic instructions, so they’re padded with 0s (they’re <em>zeroed out</em> in computer jargon) and ignored.</p>
<p>Now, let’s use the binary values in Tables 2-1 and 2-2 to translate the add instruction in line 3 of Program 1-1 into a 2-byte (or 16-bit) machine language instruction:</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Assembly Language Instruction</td>
<td class="align_left right_border">Machine Language Instruction</td>
</tr><tr><td class="left_border align_left right_border"><code>add A, B, C</code></td>
<td class="align_left right_border"><code>00000001 10000000</code></td>
</tr><tr><td class="left_border align_left right_border"><code>add C, D, A</code></td>
<td class="align_left right_border"><code>00001011 00000000</code></td>
</tr><tr><td class="left_border align_left right_border"><code>add D, B, C</code></td>
<td class="align_left right_border"><code>00001101 10000000</code></td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>sub A, D, C</code></td>
<td class="align_left right_border"><code>00010011 10000000</code></td>
</tr></table>
<p>Increasing the number of binary digits in the opcode and register fields increases the total number of instructions the machine can use and the number of registers it can have.<span class="intersentencespace"></span> For example, if you know something about binary notation, then you probably know that a 3-bit opcode allows the processor to map up to 23 mnemonics, which means that it can have up to 23, or 8, instructions in its <em>instruction set</em>; increasing the opcode size to 8 bits would allow the processor’s instruction set to contain up to 28, or 256, instructions.<span class="intersentencespace"></span> Similarly, increasing the number of bits in the register field increases the possible number of registers that the machine can have.</p>
<p>Arithmetic instructions containing an immediate value use an immediate- type instruction format, which is slightly different from the register-type format we just saw.<span class="intersentencespace"></span> In an immediate-type instruction, the first byte contains the opcode, the source register, and the destination register, while the second byte contains the immediate value, as shown in Figure 2-2.</p>
<div class="center figure" id="fig-2-2" data-tralics-id="uid50" data-number="2.2">
<div class="graphics image"><img src="images/figure_2-2.png" alt="images/figure_2-2" /></div><div class="caption"><span class="header">Figure 2.2: </span><span class="description">Machine language format for an immediate-type instruction
</span></div></div>
<p>Here are a few immediate-type arithmetic instructions translated from assembly language to machine language:</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Assembly Language Instruction</td>
<td class="align_left right_border">Machine Language Instruction</td>
</tr><tr><td class="left_border align_left right_border"><code>add C, 8, A</code></td>
<td class="align_left right_border"><code>10001000 00001000</code></td>
</tr><tr><td class="left_border align_left right_border"><code>add 5, A, C</code></td>
<td class="align_left right_border"><code>10000010 00000101</code></td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>sub 25, D, C</code></td>
<td class="align_left right_border"><code>10011110 00011001</code></td>
</tr></table>
</div>
<div id="uid51" data-tralics-id="uid51" class="subsection" data-number="2.1.3"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid51" class="heading hyperref"><span class="number">2.1.3 </span>Binary Encoding of Memory Access Instructions</a></h3>
<p>Memory-access instructions use both register- and immediate-type instruction formats exactly like those shown for arithmetic instructions.<span class="intersentencespace"></span> The only difference lies in how they use them.<span class="intersentencespace"></span> Let’s take the case of a load first.</p>
<div id="uid52" data-tralics-id="uid52" class="subsubsection" data-number="2.1.3.1"><h4><a href="#uid52" class="heading">The load Instruction</a></h4>
<p>We’ve previously seen two types of <code>load</code>, the first of which was the immediate type.<span class="intersentencespace"></span> An immediate-type <code>load</code> (see Figure 2-3) uses the immediate-type instruction format, but because the <code>load</code>’s source is an immediate value (a memory address) and not a register, the source field is unneeded and must be zeroed out.<span class="intersentencespace"></span> (The source field is not ignored, though, and in a moment we’ll see what happens if it isn’t zeroed out.)</p>
<div class="center figure" id="fig-2-3" data-tralics-id="uid53" data-number="2.3">
<div class="graphics image"><img src="images/figure_2-3.png" alt="images/figure_2-3" /></div><div class="caption"><span class="header">Figure 2.3: </span><span class="description">Machine language format for an immediate-type load
</span></div></div>
<p>Now let’s translate the immediate-type load in line 1 of Program 1-1 (12 is 1100 in binary notation):</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Assembly Language Instruction</td>
<td class="align_left right_border">Machine Language Instruction</td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>load #12, A</code></td>
<td class="align_left right_border"><code>10100000 00001100</code></td>
</tr></table>
<p>The 2-byte machine language instruction on the right is a binary representation of the assembly language instruction on the left.<span class="intersentencespace"></span> The first byte corresponds to an immediate-type <code>load</code> instruction that takes register <code>A</code> as its destination.<span class="intersentencespace"></span> The second byte is the binary representation of the number 12, which is the source address in memory that the data is to be loaded from.</p>
<p>The second type of <code>load</code> we’ve seen is the register type.<span class="intersentencespace"></span> A register-type <code>load</code> uses the register-type instruction format, but with the source2 field zeroed out and ignored, as shown in Figure 2-4.</p>
<p>In Figure 2-4, the source1 field specifies the register containing the memory address that the processor is to load data from, and the destination field specifies the register that the loaded data is to be placed in.</p>
<div class="center figure" id="fig-2-4" data-tralics-id="uid54" data-number="2.4">
<div class="graphics image"><img src="images/figure_2-4.png" alt="images/figure_2-4" /></div><div class="caption"><span class="header">Figure 2.4: </span><span class="description">Machine language format for a register-type load
</span></div></div>
<p>For a register-relative addressed <code>load</code>, we use a version of the immediate-type instruction format, shown in Figure 2-5, with the base field specifying the register that contains the base address and the offset stored in the second byte of the instruction.</p>
<div class="center figure" id="fig-2-5" data-tralics-id="uid55" data-number="2.5">
<div class="graphics image"><img src="images/figure_2-5.png" alt="images/figure_2-5" /></div><div class="caption"><span class="header">Figure 2.5: </span><span class="description">Machine language format for a register-relative load
</span></div></div>
<p>Recall from Table 2-2 that 00 is the binary number that designates register <code>A</code>.<span class="intersentencespace"></span> Therefore, as a result of the DLW-1’s particular machine language encoding scheme, any register but <code>A</code> could theoretically be used to store the base address for a register-relative load.</p>
</div>
<div id="uid56" data-tralics-id="uid56" class="subsubsection" data-number="2.1.3.2"><h4><a href="#uid56" class="heading">The store Instruction</a></h4>
<p>The register-type binary format for a <code>store</code> instruction is the same as it is for a load, except that the destination field specifies a register containing a destination memory address, and the source1 field specifies the register containing the data to be stored to memory.</p>
<p>The immediate-type machine language format for a <code>store</code>, pictured in Figure 2-6, is also similar to the immediate-type format for a <code>load</code>, except that since the destination register is not needed (the destination is the immediate memory address) the destination field is zeroed out, while the source field specifies which register holds the data to be stored.</p>
<div class="center figure" id="fig-2-6" data-tralics-id="uid57" data-number="2.6">
<div class="graphics image"><img src="images/figure_2-6.png" alt="images/figure_2-6" /></div><div class="caption"><span class="header">Figure 2.6: </span><span class="description">Machine language format for an immediate-type store
</span></div></div>
<p>The register-relative <code>store</code>, on the other hand, uses the same immediate-type instruction format used for the register-relative <code>load</code> (Figure 2-5), but the destination field is set to a nonzero value, and the offset is stored in the second byte.<span class="intersentencespace"></span> Again, the base address for a register-relative <code>store</code> can theoretically be stored in any register other than A, although by convention it’s stored in D.</p>
</div></div>
<div id="uid58" data-tralics-id="uid58" class="subsection" data-number="2.1.4"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid58" class="heading hyperref"><span class="number">2.1.4 </span>Translating an Example Program into Machine Language</a></h3>
<p>For our simple computer with four registers, three instructions, and 256 memory cells, it’s tedious but trivial to translate Program 1-1 into machine- readable binary representation using the previous tables and instruction formats.<span class="intersentencespace"></span> Program 2-1 shows the translation.</p>
<table class="tabular"><tr class="top_border bottom_border"><td class="left_border align_left right_border">Assembly Language</td>
<td class="align_left right_border">Machine Language</td>
</tr><tr><td class="left_border align_left right_border"><code>load #12, A</code></td>
<td class="align_left right_border"><code>10100000 00001100</code></td>
</tr><tr><td class="left_border align_left right_border"><code>load #13, B</code></td>
<td class="align_left right_border"><code>10100001 00001101</code></td>
</tr><tr><td class="left_border align_left right_border"><code>add A, B, C</code></td>
<td class="align_left right_border"><code>00000001 10000000</code></td>
</tr><tr class="bottom_border"><td class="left_border align_left right_border"><code>store C, #14</code></td>
<td class="align_left right_border"><code>10111000 00001110</code></td>
</tr></table>
<p>Program 2-1: A translation of Program 1-1 into machine language</p>
<p>The 1s and 0s in the rightmost column of Program 2-1 represent the high and low voltages that the computer “thinks” in.</p>
<p>Real machine language instructions are usually longer and more complex than the simple ones I’ve given here, but the basic idea is exactly the same.<span class="intersentencespace"></span> Program instructions are translated into machine language in a mechanical, predefined manner, and even in the case of a fully modern microprocessor, doing such translations by hand is merely a matter of knowing the instruction formats and having access to the right charts and tables.</p>
<p>Of course, for the most part the only people who do such translations by hand are computer engineering or computer science undergraduates who’ve been assigned them for homework.<span class="intersentencespace"></span> This wasn’t always the case, though.</p>
</div></div><div id="cid10" data-tralics-id="cid10" class="section" data-number="2.2"><h2><a href="the_mechanics_of_program_execution_fragment.html#cid10" class="heading hyperref"><span class="number">2.2 </span>The Programming Model and the ISA</a></h2>
<p>Back in the bad old days, programmers had to enter programs into the computer directly in machine language (after having walked five miles in the snow uphill to work).<span class="intersentencespace"></span> In the very early stages of computing, this was done by flipping switches.<span class="intersentencespace"></span> The programmer toggled strings of 1s and 0s into the computer’s very limited memory, ran the program, and then pored over the resulting strings of 1s and 0s to decode the answer.</p>
<p>Once memory sizes and processing power increased to the point where programmer time and effort were valuable enough relative to computing time and memory space, computer scientists devised ways of allowing the computer to use a portion of its power and memory to take on some of the burden of making its cryptic input and output a little more human-friendly.</p>
<p>In short, the tedious task of converting human-readable programs into machine-readable binary code was automated; hence the birth of assembly language programming.<span class="intersentencespace"></span> Programs could now be written using mnemonics, register names, and memory locations, before being converted by an assembler into machine language for processing.</p>
<p>In order to write assembly language programs for a machine, you have to understand the machine’s available resources: how many registers it has, what instructions it supports, and so on.<span class="intersentencespace"></span> In other words, you need a well-defined model of the machine you’re trying to program.</p>
<div id="uid59" data-tralics-id="uid59" class="subsection" data-number="2.2.1"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid59" class="heading hyperref"><span class="number">2.2.1 </span>The Programming Model</a></h3>
<p>The <em>programming model</em> is the programmer’s interface to the microprocessor.<span class="intersentencespace"></span> It hides all of the processor’s complex implementation details behind a relatively simple, clean layer of abstraction that exposes to the programmer all of the processor’s functionality.<span class="intersentencespace"></span> (See Chapter 4 for more on the history and development of the programming model.)</p>
<p>Figure 2-7 shows a diagram of a programming model for an eight-register machine.<span class="intersentencespace"></span> By now, most of the parts of the diagram should be familiar to you.<span class="intersentencespace"></span> The ALU performs arithmetic, the registers store numbers, and the <em>input-output unit</em> (I/O unit) is responsible for interacting with memory and the rest of the system (via loads and stores).<span class="intersentencespace"></span> The parts of the processor that we haven’t yet met lie in the <em>control unit</em>.<span class="intersentencespace"></span> Of these, we’ll cover the <em>program counter</em> and the <em>instruction register</em> now.</p>
</div>
<div id="uid60" data-tralics-id="uid60" class="subsection" data-number="2.2.2"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid60" class="heading hyperref"><span class="number">2.2.2 </span>The Instruction Register and Program Counter</a></h3>
<p>Because programs are stored in memory as ordered sequences of instruc- tions and memory is arranged as a linear series of addresses, each instruction in a program lives at its own memory address.<span class="intersentencespace"></span> In order to step through and execute the lines of a program, the computer simply begins at the program’s starting address and then steps through each successive memory location, fetching each successive instruction from memory, placing it in a special register, and executing it as shown in Figure 2-8.</p>
<div class="center figure" id="fig-2-7" data-tralics-id="uid61" data-number="2.7">
<div class="graphics image"><img src="images/figure_2-7.png" alt="images/figure_2-7" /></div><div class="caption"><span class="header">Figure 2.7: </span><span class="description">The programming model for a simple eight-register machine
</span></div></div>
<p>The instructions in our DLW-1 computer are two bytes long.<span class="intersentencespace"></span> If we assume that each memory cell holds one byte, then the DLW-1 must step through memory by fetching instructions from two cells at a time.</p>
<div class="center figure" id="fig-2-8" data-tralics-id="uid62" data-number="2.8">
<div class="graphics image"><img src="images/figure_2-8.png" alt="images/figure_2-8" /></div><div class="caption"><span class="header">Figure 2.8: </span><span class="description">A simple computer with instruction and data registers
</span></div></div>
<p>For example, if the starting address in Program 1-1 were #500, it would look like Figure 2-9 in memory (with the instructions rendered in machine language, not assembly language, of course).</p>
<div class="center figure" id="fig-2-9" data-tralics-id="uid63" data-number="2.9">
<div class="graphics image"><img src="images/figure_2-9.png" alt="images/figure_2-9" /></div><div class="caption"><span class="header">Figure 2.9: </span><span class="description">An illustration of Program 1-1 in memory, starting at address #500
</span></div></div>
</div>
<div id="uid64" data-tralics-id="uid64" class="subsection" data-number="2.2.3"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid64" class="heading hyperref"><span class="number">2.2.3 </span>The Instruction Fetch: Loading the Instruction Register</a></h3>
<p>An <em>instruction fetch</em> is a special type of load that happens automatically for every instruction.<span class="intersentencespace"></span> It always takes the address that’s currently in the program counter register as its source and the <em>instruction register</em> as its destination.<span class="intersentencespace"></span> The control unit uses a fetch to load each instruction of a program from memory into the instruction register, where that instruction is <em>decoded</em> before being executed; and while that instruction is being decoded, the processor places the address of the next instruction into the program counter by incrementing the address that’s currently in the program counter, so that the newly incremented address points to the next instruction the sequence.<span class="intersentencespace"></span> In the case of our DLW-1, the program counter is incremented by two every time an instruction is fetched, because the two-byte instructions begin at every other byte in memory.</p>
</div>
<div id="uid65" data-tralics-id="uid65" class="subsection" data-number="2.2.4"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid65" class="heading hyperref"><span class="number">2.2.4 </span>Running a Simple Program: the Fetch-Execute Loop</a></h3>
<p>In Chapter 1 we discussed the steps a processor takes to perform calculations on numbers using the ALU in combination with a fetched arithmetic instruc- tion.<span class="intersentencespace"></span> Now let’s look at the steps the processor takes in order to fetch a series of instructions—a program—and feed them to either the ALU (in the case of arithmetic instructions) or the memory access hardware (in the case of loads and stores):</p>
<ol>
<li><em>Fetch</em> the next instruction from the address stored in the program counter, and load that instruction into the instruction register.<span class="intersentencespace"></span> Increment the program counter.<span class="intersentencespace"></span>
</li>
<li><em>Decode</em> the instruction in the instruction register.<span class="intersentencespace"></span>
</li>
<li><em>Execute</em> the instruction in the instruction register, using the following
rules:
<ul>
<li>If the instruction is an arithmetic instruction, execute it using the ALU and register file.<span class="intersentencespace"></span>
</li>
<li>If the instruction is a memory access instruction, execute it using the memory-access hardware.<span class="intersentencespace"></span>
</li></ul>
<p>These three steps are fairly straightforward, and with one modification
they describe the way that microprocessors execute programs (as we’ll see in the section “Branch Instructions” on page 30).<span class="intersentencespace"></span> Computer scientists often refer to these steps as the <em>fetch-execute loop</em> or the <em>fetch-execute cycle</em>.<span class="intersentencespace"></span> The fetch- execute loop is repeated for as long as the computer is powered on.<span class="intersentencespace"></span> The machine iterates through the entire loop, from step 1 to step 3, over and over again many millions or billions of times per second in order to run programs.<span class="intersentencespace"></span></p>
</li></ol>
<p>Let’s run through the three steps with our example program as shown in Figure 2-9.<span class="intersentencespace"></span> (This example presumes that #500 is already in the program counter.)<span class="intersentencespace"></span> Here’s what the processor does, in order:</p>
<ol>
<li>Fetch the instruction beginning at #500, and load <code>load #12, A</code> into the instruction register.<span class="intersentencespace"></span> Increment the program counter to #502.<span class="intersentencespace"></span>
</li>
<li>Decode <code>load #12, A</code> in the instruction register.<span class="intersentencespace"></span>
</li>
<li>Execute <code>load #12, A</code> from the instruction register, using the memory-
access hardware.<span class="intersentencespace"></span>
</li>
<li>Fetch the instruction beginning at #502, and load <code>load #13, B</code> in the instruction register.<span class="intersentencespace"></span> Increment the program counter to #504.<span class="intersentencespace"></span>
</li>
<li>Decode <code>load #13, B</code> in the instruction register.<span class="intersentencespace"></span>
</li>
<li>Execute <code>load #13, B</code> from the instruction register, using the memory-
access hardware.<span class="intersentencespace"></span>
</li>
<li>Fetch the instruction beginning at #504, and load <code>add A, B, C</code> into the instruction register.<span class="intersentencespace"></span> Increment the program counter to #506.<span class="intersentencespace"></span>
</li>
<li>Decode <code>add A, B, C</code> in the instruction register.<span class="intersentencespace"></span>
</li>
<li>Execute <code>add A, B, C</code> from the instruction register, using the ALU and
register file.<span class="intersentencespace"></span>
</li>
<li>Fetch the instruction at #506, and load <code>store C, #14</code> in the instruction register.<span class="intersentencespace"></span> Increment the program counter to #508.<span class="intersentencespace"></span>
</li>
<li>Decode <code>store C, #14</code> in the instruction register.<span class="intersentencespace"></span>
</li>
<li>Execute <code>store C, #14</code> from the instruction register, using the memory-
access hardware.<span class="intersentencespace"></span>
</li></ol>
<div class="aside" id="aside-note_2-2" data-tralics-id="uid83" data-number="2.2"><div class="heading"><span class="number">Box 2.2.</span> 
</div>
<p class="noindent">To zoom in on the execute steps of the preceding sequence, revisit Chapter 1, and particularly the sections“Refining the File-Clerk Model” on page 6 and “RAM: When the Registers Alone Don’t Cut It” on page 8.<span class="intersentencespace"></span> If you do, you’ll gain a pretty good understanding of what’s involved in executing a program on any machine.<span class="intersentencespace"></span> Sure, there are important machine-specific variations for most of what I’ve presented here, but the general outlines (and even a decent number of the specifics) are the same.</p>

</div></div></div><div id="cid11" data-tralics-id="cid11" class="section" data-number="2.3"><h2><a href="the_mechanics_of_program_execution_fragment.html#cid11" class="heading hyperref"><span class="number">2.3 </span>The Clock</a></h2>
<p>Steps 1 through 12 in the previous section don’t take an arbitrary amount of time to complete.<span class="intersentencespace"></span> Rather, they’re performed according to the pulse of the clock that governs every action the processor takes.</p>
<p>This clock pulse, which is generated by a <em>clock generator</em> module on the motherboard and is fed into the processor from the outside, times the func- tioning of the processor so that, on the DLW-1 at least, all three steps of the fetch-execute loop are completed in exactly one beat of the clock.<span class="intersentencespace"></span> Thus, the program in Figure 2-9, as I’ve traced its execution in the preceding section, takes exactly four clock beats to finish execution, because a new instruction is fetched on each beat of the clock.</p>
<p>One obvious way to speed up the execution of programs on the DLW-1 would be to speed up its clock generator so that each step takes less time to complete.<span class="intersentencespace"></span> This is generally true of all microprocessors, hence the race among microprocessor designers to build and market chips with ever-higher clock speeds.<span class="intersentencespace"></span> (We’ll talk more about the relationship between clock speed and performance in Chapter 3.)</p>
</div><div id="cid12" data-tralics-id="cid12" class="section" data-number="2.4"><h2><a href="the_mechanics_of_program_execution_fragment.html#cid12" class="heading hyperref"><span class="number">2.4 </span>Branch Instructions</a></h2>
<p>As I’ve presented it so far, the processor moves through each line in a pro- gram in sequence until it reaches the end of the program, at which point the program’s output is available to the user.</p>
<p>There are certain instructions in the instruction stream, however, that allow the processor to jump to a program line that is out of sequence.<span class="intersentencespace"></span> For instance, by inserting a branch instruction into line 5 of a program, we could cause the processor’s control unit to jump all the way down to line 20 and begin executing there (a forward branch), or we could cause it to jump back up to line 1 (a backward branch).<span class="intersentencespace"></span> Because a program is an ordered sequence of instructions, by including forward and backward branch instructions, we can arbitrarily move about in the program.<span class="intersentencespace"></span> This is a powerful ability, and branches are an essential part of computing.</p>
<p>Rather than thinking about forward or backward branches, it’s more useful for our present purposes to categorize all branches as being one of the following two types: conditional branches or unconditional branches.</p>
<div id="uid84" data-tralics-id="uid84" class="subsection" data-number="2.4.1"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid84" class="heading hyperref"><span class="number">2.4.1 </span>Unconditional Branch</a></h3>
<p>An unconditional branch instruction consists of two parts: the branch instruction and the target address.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>jump #target
</pre></div></div>
<p>For an unconditional branch, <code>#target</code> can be either an immediate value, like #12, or an address stored in a register, like <code>#D</code>.</p>
<p>Unconditional branches are fairly easy to execute, since all that the computer needs to do upon decoding such a branch in the instruction register is to have the control unit replace the address currently in the program counter with branch’s target address.<span class="intersentencespace"></span> Then the next time the processor goes to fetch the instruction at the address given by the program counter, it’ll fetch the address at the branch target instead.</p>
</div>
<div id="uid85" data-tralics-id="uid85" class="subsection" data-number="2.4.2"><h3><a href="the_mechanics_of_program_execution_fragment.html#uid85" class="heading hyperref"><span class="number">2.4.2 </span>Conditional Branch</a></h3>
<p>Though it has the same basic instruction format as the unconditional branch (instruction #target), the <em>conditional branch</em> instruction is a little more complicated, because it involves jumping to the target address only if a certain condition is met.</p>
<p>For example, say we want to jump to a new line of the program only if the previous arithmetic instruction’s result is zero; if the result is nonzero, we want to continue executing normally.<span class="intersentencespace"></span> We would use a conditional branch instruction that first checks to see if the previously executed arithmetic instruction yielded a zero result, and then writes the branch target into the program counter if it did.</p>
<p>Because of such conditional jumps, we need a special register or set of registers in which to store information about the results of arithmetic instructions—information such as whether the previous result was zero or nonzero, positive or negative, and so on.</p>
<p>Different architectures handle this in different ways, but in our DLW-1, this is the function of the <em>processor status word</em> (PSW) register.<span class="intersentencespace"></span> On the DLW-1, every arithmetic operation stores different types of data about its outcome in the PSW upon completion.<span class="intersentencespace"></span> To execute a conditional branch, the DLW-1 must first evaluate the condition on which the branch depends (e.g., “is the previous arithmetic instruction’s result zero?” in the preceding example) by checking the appropriate bit in the PSW to see if that condition is true or false.<span class="intersentencespace"></span> If the branch condition evaluates to true, then the control unit replaces the address in the program counter with the branch target address.<span class="intersentencespace"></span> If the branch condition evaluates to false, then the program counter is left as-is, and the next instruction in the normal program sequence is fetched on the next cycle.</p>
<p>For example, suppose we had just subtracted the number in A from the number in B, and if the result was zero (that is, if the two numbers were equal), we want to jump to the instruction at memory address #106.<span class="intersentencespace"></span> Program 2-2 shows what assembler code for such a conditional branch might look like.</p>
<div class="codelisting" id="code-program_2-2" data-tralics-id="uid86" data-number="2.1"><div class="heading"><span class="number">Listing 2.1:</span> 

<span class="description">Assembler code for a conditional branch</span>
</div>

<div class="code"><div class="highlight"><pre>sub A, B, C   //Subtract the number in register A from the number in register B and store the result in C.
jumpz #106    //Check the PSW, and if the result of the previous instruction was zero, jump to the instruction at address #106. If the result was nonzero, continue on to line 18.
add A, B, C  //Add the numbers in registers A and B and store the result in C.
</pre></div></div></div><p>The <code>jumpz</code> instruction causes the processor to check the PSW to determine whether a certain bit is 1 (true) or 0 (false).<span class="intersentencespace"></span> If the bit is 1, the result of the subtraction instruction was 0 and the program counter must be loaded with the branch target address.<span class="intersentencespace"></span> If the bit is 0, the program counter is incremented to point to the next instruction in sequence (which is the add instruction in line 18).</p>
<p>There are other bits in the PSW that specify other types of information about the result of the previous operation (whether it is positive or negative, is too large for the registers to hold, and so on).<span class="intersentencespace"></span> As such, there are also other types of conditional branch instructions that check these bits.<span class="intersentencespace"></span> For instance, the <code>jumpn</code> instruction jumps to the target address if the result of the preceding arithmetic operation was negative; the <code>jumpo</code> instruction jumps to the target address if the result of the previous operation was too large and overflowed the register.<span class="intersentencespace"></span> If the machine language instruction format of the DLW-1 could accommodate more than eight possible instructions, we could add more types of conditional jumps.</p>
<div id="uid87" data-tralics-id="uid87" class="subsubsection" data-number="2.4.2.1"><h4><a href="#uid87" class="heading">Branch Instructions and the Fetch-Execute Loop</a></h4>
<p>Now that we have looked at the basics of branching, we can modify our three- step summary of program execution to include the possibility of a branch instruction:</p>
<ol>
<li>Fetch the next instruction from the address stored in the program counter, and load that instruction into the instruction register.<span class="intersentencespace"></span> Increment the program counter.<span class="intersentencespace"></span>
</li>
<li>Decode the instruction in the instruction register.<span class="intersentencespace"></span>
</li>
<li>Execute the instruction in the instruction register, using the following rules:
<ul>
<li>If the instruction is an arithmetic instruction, then execute it using the ALU and register file.<span class="intersentencespace"></span>
</li>
<li>If the instruction is a memory-access instruction, then execute it using the memory hardware.<span class="intersentencespace"></span>
</li>
<li>If the instruction is a branch instruction, then execute it using the control unit and the program counter.<span class="intersentencespace"></span> (For a taken branch, write the branch target address into the program counter.)<span class="intersentencespace"></span>
</li></ul>
</li></ol>
<p>In short, you might say that branch instructions allow the programmer to redirect the processor as it travels through the instruction stream.<span class="intersentencespace"></span> Branches point the processor to different sections of the code stream by manipulating its control unit, which, because it contains the instruction register and pro- gram counter, is the rudder of the CPU.</p>
</div>
<div id="uid94" data-tralics-id="uid94" class="subsubsection" data-number="2.4.2.2"><h4><a href="#uid94" class="heading">The Branch Instruction as a Special Type of Load</a></h4>
<p>Recall that an instruction fetch is a special type of <code>load</code> that happens automatically for every instruction and that always takes the address in the program counter as its source and the instruction register as its destination.<span class="intersentencespace"></span> With that in mind, you might think of a branch instruction as a similar kind of <code>load</code>, but under the control of the programmer instead of the CPU. The branch instruction is a load that takes the address specified by <code>#target</code> as its source and the instruction register as its destination.</p>
<p>Like a regular <code>load</code>, a branch instruction can take as its target an address stored in a register.<span class="intersentencespace"></span> In other words, branch instructions can use register-relative addressing just like regular <code>load</code> instructions.<span class="intersentencespace"></span> This capability is useful because it allows the computer to store blocks of code at arbitrary places in memory.<span class="intersentencespace"></span> The programmer doesn’t need to know the address at which a block of code will wind up before writing a branch instruction that jumps to that particular block; all he or she needs is a way to get to the memory location where the operating system, which is responsible for managing memory, has stored the starting address of the desired block of code.</p>
<p>Consider Program 2-3, in which the programmer knows that the operating system has placed the address of the branch target in line 17 in register <code>C</code>.<span class="intersentencespace"></span> Upon reaching line 17, the computer jumps to the address stored in C by copying the contents of C into the instruction register.</p>
<div class="codelisting" id="code-program_2-3" data-tralics-id="uid95" data-number="2.2"><div class="heading"><span class="number">Listing 2.2:</span> 

<span class="description">A conditional branch that uses an address stored in a register</span>
</div>

<div class="code"><div class="highlight"><pre>sub A, B, A   //Subtract the number in register A from the number in register B and store the result in A.
jumpz #C      //Check the PSW, and if the result of the previous instruction was zero, jump to the instruction at the address stored in C. If the result was nonzero, continue on to line 18.
add A, 15, A  //Add 15 to the number in A and store the result in A.
</pre></div></div></div><p>When a programmer uses register-relative addressing with a branch instruction, the operating system must load a certain register with the base address of the <em>code segment</em> in which the program resides.<span class="intersentencespace"></span> Like the data segment, the code segment is a contiguous block of memory cells, but its cells store instructions instead of data.<span class="intersentencespace"></span> So to jump to line 15 in the currently running program, assuming that the operating system has placed the base address of the code segment in C, the programmer could use the following instruction:</p>
<div class="code"><div class="highlight"><pre>jump #(C + 30)  //Jump to the instruction located 30 bytes away from the start of the code segment. (Each instruction is 2 bytes in length, so this puts us at the 15 instruction.)
</pre></div></div>
</div>
<div id="uid96" data-tralics-id="uid96" class="subsubsection" data-number="2.4.2.3"><h4><a href="#uid96" class="heading">Branch Instructions and Labels</a></h4>
<p>In programs written for real-world architectures, branch targets don’t usually take the form of either immediate values or register-relative values.<span class="intersentencespace"></span> Rather, the programmer places a <em>label</em> on the line of code to which he or she wants to jump, and then puts that label in the branch’s target field.<span class="intersentencespace"></span> Program 2-4 shows a portion of assembly language code that uses labels.</p>
<div class="codelisting" id="code-program_2-4" data-tralics-id="uid97" data-number="2.3"><div class="heading"><span class="number">Listing 2.3:</span> 

<span class="description">Assembly language code that uses labels</span>
</div>

<div class="code"><div class="highlight"><pre>      sub A, B, A
      jumpz LBL1
      add A, 15, A
      store A, #(D + 16)
LBL1: add A, B, B
      store B, #(D + 16)
</pre></div></div></div><p>In this example, if the contents of <code>A</code> and <code>B</code> are equal, the computer will jump to the instruction with the label LBL1 and begin executing there, skipping the instructions between the <code>jump</code> and the labeled <code>add</code>.<span class="intersentencespace"></span> Just as the absolute memory addresses used in <code>load</code> and <code>store</code> instructions are modified at load time to fit the location in memory of the program’s data segment, labels like LBL1 are changed at load time into memory addresses that reflect the location in memory of the program’s code segment.</p>
</div></div></div><div id="cha-pipelined_execution" data-tralics-id="cid13" class="section" data-number="2.5"><h2><a href="the_mechanics_of_program_execution_fragment.html#cha-pipelined_execution" class="heading hyperref"><span class="number">2.5 </span>Excursus: Booting Up</a></h2>
<p>If you’ve been around computers for any length of time, you’ve heard the terms reboot or boot up used in connection with either resetting the computer to its initial state or powering it on initially.<span class="intersentencespace"></span> The term boot is a shortened version of the term bootstrap, which is itself a reference to the seemingly impossible task a computer must perform on start-up, namely, “pulling itself up by its own bootstraps.”</p>
<p>I say “seemingly impossible,” because when a computer is first powered on there is no program in memory, but programs contain the instructions that make the computer run.<span class="intersentencespace"></span> If the processor has no program running when it’s first powered on, then how does it know where to fetch the first instruc- tion from?<span class="intersentencespace"></span> The solution to this dilemma is that the microprocessor, in its power-on default state, is hard-wired to fetch that first instruction from a predetermined address in memory.<span class="intersentencespace"></span> This first instruction, which is loaded into the processor’s instruction register, is the first line of a program called the BIOS that lives in a special set of storage locations—a small read-only memory (ROM) module attached to the computer’s motherboard.<span class="intersentencespace"></span> It’s the job of the BIOS to perform basic tests of the RAM and peripherals in order to verify that everything is working properly.<span class="intersentencespace"></span> Then the boot process can continue.</p>
<p>At the end of the BIOS program lies a jump instruction, the target of which is the location of a <em>bootloader</em> program.<span class="intersentencespace"></span> By using a <code>jump</code>, the BIOS hands off control of the system to this second program, whose job it is to search for and load the computer’s operating system from the hard disk.<span class="intersentencespace"></span> The <em>operating system</em> (OS) loads and unloads all of the other programs that run on the computer, so once the OS is up and running the computer is ready to interact with the user.</p>
<data-label>cha-superscalar_execution</data-label><data-label>cha-the_intel_pentium_and_pentium_pro</data-label><data-label>cha-arm_1</data-label><data-label>cha-intels_pentium_4_vs_arm_2_philosophy</data-label><data-label>cha-intels_pentium_4_vs_arm_2_back_end</data-label><data-label>cha-64_bit_computing_and_x86_64</data-label><data-label>cha-arm_3</data-label><data-label>cha-understanding_caching_and_performance</data-label><data-label>cha-intels_pentium_m_and_core</data-label></div>